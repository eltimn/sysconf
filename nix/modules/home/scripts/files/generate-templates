#!/usr/bin/env bash
#
# Generate JSON file with nix flake templates from various sources
# Sources are defined in the init-new-project skill
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DEFAULT_OUTPUT="${SCRIPT_DIR}/nix-templates.json"

# Sources from init-new-project skill (in priority order)
declare -a SOURCES=(
    "github:eltimn/sysconf|https://raw.githubusercontent.com/eltimn/sysconf/main/flake.nix|github|eltimn|sysconf"
    "github:NixOS/templates|https://raw.githubusercontent.com/NixOS/templates/master/flake.nix|github|NixOS|templates"
    "github:akirak/flake-templates|https://raw.githubusercontent.com/akirak/flake-templates/master/flake.nix|github|akirak|flake-templates"
    "github:the-nix-way/dev-templates|https://raw.githubusercontent.com/the-nix-way/dev-templates/main/flake.nix|flakehub|the-nix-way|dev-templates"
)

# Function to fetch flake.nix content
fetch_flake() {
    local url="$1"
    curl -fsSL "$url" 2>/dev/null || echo ""
}

# Function to extract templates section with proper brace counting
extract_templates_section() {
    local content="$1"
    local in_templates=0
    local brace_count=0
    local output=""

    while IFS= read -r line; do
        # Check for templates = { or templates = rec {
        if [[ $in_templates -eq 0 ]] && echo "$line" | grep -qE 'templates\s*=\s*(rec\s+)?\{'; then
            in_templates=1
            brace_count=1
            continue
        fi

        if [[ $in_templates -eq 1 ]]; then
            # Count braces
            local open_braces
            local close_braces
            open_braces=$(echo "$line" | grep -o '{' | wc -l)
            close_braces=$(echo "$line" | grep -o '}' | wc -l)
            brace_count=$((brace_count + open_braces - close_braces))

            # If we're back to 0, we've closed the templates section
            if [[ $brace_count -eq 0 ]]; then
                break
            fi

            output="${output}${line}"$'\n'
        fi
    done <<< "$content"

    echo "$output"
}

# Function to extract description from a line
extract_description() {
    local line="$1"
    echo "$line" | grep -oE 'description\s*=\s*"[^"]*"' | head -1 | sed 's/description\s*=\s*"\([^"]*\)".*/\1/'
}

# Function to parse templates from content
parse_templates() {
    local content="$1"
    local source_name="$2"
    local owner="$3"
    local repo="$4"
    local type="$5"

    local templates_section
    templates_section=$(extract_templates_section "$content")

    if [[ -z "$templates_section" ]]; then
        return
    fi

    # Parse each template entry
    local in_template=0
    local template_name=""
    local description=""
    local template_brace_count=0

    while IFS= read -r line; do
        # Skip empty lines and comments
        [[ -z "$line" ]] && continue
        [[ "$line" =~ ^[[:space:]]*# ]] && continue

        # Check for template name start (e.g., "basic = {")
        if [[ $in_template -eq 0 ]] && echo "$line" | grep -qE '^\s*[a-zA-Z0-9_-]+\s*=\s*\{'; then
            template_name=$(echo "$line" | sed -E 's/^\s*([a-zA-Z0-9_-]+).*/\1/')
            # Skip if it's an alias like "default = basic;"
            if echo "$line" | grep -qE '\{\s*$'; then
                in_template=1
                template_brace_count=1
                description=""
            fi
            continue
        fi

        if [[ $in_template -eq 1 ]]; then
            # Count braces to track nested structures
            local open_braces
            local close_braces
            open_braces=$(echo "$line" | grep -o '{' | wc -l)
            close_braces=$(echo "$line" | grep -o '}' | wc -l)
            template_brace_count=$((template_brace_count + open_braces - close_braces))

            # Extract description
            local desc
            desc=$(extract_description "$line")
            if [[ -n "$desc" ]]; then
                description="$desc"
            fi

            # End of template (brace count returns to 0)
            if [[ $template_brace_count -eq 0 ]]; then
                if [[ -n "$template_name" && -n "$description" ]]; then
                    local ref
                    if [[ "$type" == "flakehub" ]]; then
                        ref="https://flakehub.com/f/${owner}/${repo}/0.1#${template_name}"
                    else
                        ref="github:${owner}/${repo}#${template_name}"
                    fi
                    printf '%s\t%s\t%s\t%s\n' "$template_name" "$ref" "$description" "$source_name"
                fi
                in_template=0
                template_name=""
                description=""
            fi
        fi
    done <<< "$templates_section"
}

# Function to generate JSON file
generate_json() {
    local output_file="$1"
    local temp_file
    temp_file=$(mktemp)
    local all_templates=""
    local total_count=0

    echo "Fetching templates from sources..." >&2

    for source_info in "${SOURCES[@]}"; do
        IFS='|' read -r source_name url type owner repo <<< "$source_info"

        echo "  Fetching from ${source_name}..." >&2

        local content
        content=$(fetch_flake "$url")

        if [[ -z "$content" ]]; then
            echo "    Failed to fetch templates" >&2
            continue
        fi

        local templates
        templates=$(parse_templates "$content" "$source_name" "$owner" "$repo" "$type")

        if [[ -n "$templates" ]]; then
            local count
            count=$(echo "$templates" | wc -l)
            echo "    Found ${count} templates" >&2
            all_templates="${all_templates}${templates}\n"
            total_count=$((total_count + count))
        else
            echo "    No templates found" >&2
        fi
    done

    if [[ -z "$all_templates" ]]; then
        echo "No templates found!" >&2
        rm -f "$temp_file"
        return 1
    fi

    # Build JSON array
    local json_array="["
    local first=1

    while IFS=$'\t' read -r name ref description source; do
        [[ -z "$name" ]] && continue

        if [[ $first -eq 0 ]]; then
            json_array="${json_array},"
        fi
        first=0

        # Escape special characters in JSON
        local esc_name esc_ref esc_desc esc_source
        esc_name=$(echo "$name" | sed 's/\\/\\\\/g; s/"/\\"/g')
        esc_ref=$(echo "$ref" | sed 's/\\/\\\\/g; s/"/\\"/g')
        esc_desc=$(echo "$description" | sed 's/\\/\\\\/g; s/"/\\"/g')
        esc_source=$(echo "$source" | sed 's/\\/\\\\/g; s/"/\\"/g')

        json_array="${json_array}{\"name\":\"${esc_name}\",\"ref\":\"${esc_ref}\",\"description\":\"${esc_desc}\",\"source\":\"${esc_source}\"}"
    done <<< "$(echo -e "$all_templates" | sort -t$'\t' -k4,4 -k1,1)"

    json_array="${json_array}]"

    # Build sources array for metadata
    local sources_array="["
    local first_source=1
    for source_info in "${SOURCES[@]}"; do
        IFS='|' read -r source_name _ _ _ _ <<< "$source_info"
        if [[ $first_source -eq 0 ]]; then
            sources_array="${sources_array},"
        fi
        first_source=0
        sources_array="${sources_array}\"${source_name}\""
    done
    sources_array="${sources_array}]"

    # Build full JSON object
    cat > "$temp_file" << EOF
{
  "templates": ${json_array},
  "metadata": {
    "total_count": ${total_count},
    "sources": ${sources_array},
    "generated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
  }
}
EOF

    # Validate and format with jq if available
    if command -v jq &> /dev/null; then
        jq . "$temp_file" > "$output_file"
        rm -f "$temp_file"
    else
        mv "$temp_file" "$output_file"
    fi

    echo "Generated ${output_file} with ${total_count} templates" >&2
    return 0
}

# Main
output_file="$DEFAULT_OUTPUT"
force=false

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--force)
            force=true
            shift
            ;;
        -o|--output)
            output_file="$2"
            shift 2
            ;;
        -h|--help)
            echo "Usage: $(basename "$0") [OPTIONS] [OUTPUT_FILE]"
            echo ""
            echo "Generate JSON file with nix flake templates from various sources"
            echo ""
            echo "Options:"
            echo "  -o, --output FILE   Output file path (default: nix-templates.json)"
            echo "  -f, --force         Force update even if file exists"
            echo "  -h, --help          Show this help message"
            exit 0
            ;;
        -*)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
        *)
            output_file="$1"
            shift
            ;;
    esac
done

# Check if file exists
if [[ -f "$output_file" && "$force" != true ]]; then
    echo "${output_file} already exists. Use -f to force update." >&2
    exit 0
fi

generate_json "$output_file"
